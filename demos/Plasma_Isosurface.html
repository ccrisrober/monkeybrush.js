<!DOCTYPE html>
<html>
<head>
    <title>Plasma Isosurface</title>
    <link rel="stylesheet" type="text/css" href="./libs/style.css" />
</head>
<body>
    <!-- Based on https://github.com/soulwire/Plasmatic-Isosurface -->
    <div class="spinner" id="spinner">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
    <div id="stats"></div>
    <div id="samplesPassed"></div>
    <script type="text/javascript" src="./libs/libraries.js"></script>

    <script type="text/javascript" src="../dist/output.js"></script>

    <canvas id="canvas" width="512" height="512"></canvas>

    <script type="x-shader/x-vertex" id="shader-vs">#version 300 es
        precision highp float;
        layout(location = 0) in vec3 vertPosition;
        void main(void) {
            gl_Position = vec4(vertPosition, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="shader-fs">#version 300 es
        precision highp float;

        out vec4 fragColor;

        uniform float iGlobalTime;
        uniform vec2 iResolution;
        uniform sampler2D tex;

        uniform bool scanlines;
        uniform float brightness;
        uniform float blobiness;
        uniform float particles;
        uniform float energy;

        float noise( vec2 co ){
            return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );
        }

        void main( void ) {

            vec2 position = ( gl_FragCoord.xy / iResolution.x );
            float t = iGlobalTime * energy;

            float a = 0.0;
            float b = 0.0;
            float c = 0.0;

            vec2 pos, center = vec2( 0.5, 0.5 * (iResolution.y / iResolution.x) );

            float na, nb, nc, nd, d;
            float limit = particles / 80.0;
            float step = 1.0 / particles;
            float n = 0.0;

            for ( float i = 0.0; i <= 1.0; i += 0.025 ) {

                if ( i <= limit ) {

                    vec2 np = vec2(n, 1-1);

                    na = noise( np * 0.1 );
                    nb = noise( np * 3.1 );
                    nc = noise( np * 1.8 );
                    nd = noise( np * 2.7 );

                    pos = center;
                    pos.x += sin(t*na) * cos(t*nb) * tan(t*na*0.15) * 0.3;
                    pos.y += tan(t*nc) * sin(t*nd) * 0.1;

                    d = pow( 1.6*na / length( pos - position ), blobiness );

                    if ( i < limit * 0.3333 ) a += d;
                    else if ( i < limit * 0.6666 ) b += d;
                    else c += d;

                    n += step;
                }
            }

            vec3 col = vec3(a * c, b * c, a * b) * 0.0001 * brightness;
            fragColor = vec4(col, 1.0);
            if ( scanlines ) {
                fragColor.rgb -= mod( gl_FragCoord.y, 5.0 ) < 1.0 ? 0.5 : 0.0;
            }
        }
    </script>
    <script type="text/javascript">
        var MyConfig = function () {
            return {
                brightness: 0.8,
                blobiness: 1.5,
                particles: 40,
                energy: 1.01,
                scanlines: false
            };
        };
        var MyScene = (function (_super) {
            __extends(MyScene, _super);
            function MyScene() {
                _super.call(this, "App", new MB.GLContextW2(document.getElementById("canvas")), MyConfig());
                this.mainShader = "prog";
            };
            MyScene.prototype.initialize = function () {
                var _this = this;
                MB.ProgramManager.addWithFun("prog", function () {
                    var prog = new MB.Program(_this.context);
                    prog.addShader("shader-vs", MB.ctes.ShaderType.vertex, MB.ctes.ReadMode.read_script);
                    prog.addShader("shader-fs", MB.ctes.ShaderType.fragment, MB.ctes.ReadMode.read_script);
                    prog.compile();
                    prog.use();
                    prog.addUniforms(["iGlobalTime", "iResolution", "brightness", "blobiness", "particles", "scanlines", "energy"]);
                    console.log(prog);
                    return prog;
                });
                this.postProcess = new MB.PostProcess(this.context);
            };
            MyScene.prototype.update = function (dt) {
                this.__resize__();
                this.dt = dt;
            };
            MyScene.prototype.draw = function () {
                this.clearColorAndDepth();
                var prog = MB.ProgramManager.get(this.mainShader);
                prog.use();
                prog.sendUniform1f("iGlobalTime", this.dt);
                var canvas = this.canvas;
                prog.sendUniform2f("iResolution", canvas.width, canvas.height);
                prog.sendUniform1f("brightness", this.text.brightness);
                prog.sendUniform1f("blobiness", this.text.blobiness);
                prog.sendUniform1f("energy", this.text.energy);
                prog.sendUniform1b("scanlines", this.text.scanlines);
                prog.sendUniform1f("particles", this.text.particles);
                this.postProcess.render();
            };
            MyScene.prototype.textCB = function (gui) {
                gui.add(this.text, "brightness", 0.01, 1.0);
                gui.add(this.text, "blobiness", 0.1, 3.0);
                gui.add(this.text, "energy", 0.1, 3.0);
                gui.add(this.text, "scanlines", true);
                gui.add(this.text, "particles").min(1).max(150).step(1);
            };
            return MyScene;
        }(MB.App));
        window.onload = function () {
            var myScene = new MyScene();
            myScene.start();
        };
    </script>
</body>
</html>
