<!DOCTYPE html>
<html>
<head>
    <title>Ubo Spline</title>
    <link rel="stylesheet" type="text/css" href="./libs/style.css" />
</head>
<body>
    <div class="spinner" id="spinner">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
    <div id="stats"></div>
    <div id="samplesPassed"></div>
    <script type="text/javascript" src="./libs/libraries.js"></script>

    <script type="text/javascript" src="../dist/output.js"></script>

    <script type="text/javascript">
        var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        var SimpleConfig = function () {
            return {
                resume: true,
                lod: 1,
                numPoints: 256
            };
        };
        var MyScene = (function (_super) {
            __extends(MyScene, _super);
            function MyScene() {
                _super.call(this, SimpleConfig(), "EY", 2);
                this.drawTick = true;
                this.mainShader = "prog";
                this.angle = 0;
            }
            MyScene.prototype.loadAssets = function () { };
            ;
            MyScene.prototype.initialize = function () {
                var _this = this;
                MB.ProgramManager.addWithFun("prog", function () {
                    var prog = new MB.Program();
                    prog.addShader("#version 300 es\n            uniform int lod;\n            uniform int numPoints;\n            uniform mat4 transform;\n\n            uniform ControlPoints {\n                vec3[256] points;\n            };\n\n            void main(void) {\n                int i = gl_VertexID % lod;\n                int segment = gl_VertexID / lod;\n                int start = -3 + segment;\n                float t = float(i) / float(lod);\n                float t2 = t * t;\n                float t3 = t2 * t;\n                float it = 1.0 - t;\n                float w0 = it * it * it / 6.0;\n                float w1 = 0.5 * t3 - t2 + 2.0 / 3.0;\n                float w2 = 0.5 * (-t3 + t2 + t) + 1.0 / 6.0;\n                float w3 = t3 / 6.0;\n                vec3 p =    w0 * points[clamp(start+0, 0, numPoints - 1)] +\n                            w1 * points[clamp(start+1, 0, numPoints - 1)] +\n                            w2 * points[clamp(start+2, 0, numPoints - 1)] +\n                            w3 * points[clamp(start+3, 0, numPoints - 1)];\n                gl_Position = transform * vec4(p, 1.0);\n                gl_PointSize = 10.0;\n            }", MB.ctes.ShaderType.vertex, MB.ctes.ReadMode.read_text);
                    prog.addShader("#version 300 es\n            precision highp float;\n            out vec4 fragColor;\n            void main(void) {\n                fragColor = vec4(1.0);\n            }\n            ", MB.ctes.ShaderType.fragment, MB.ctes.ReadMode.read_text);
                    prog._compile();
                    prog._link();
                    prog.use();
                    prog.addUniforms(["transform", "lod", "numPoints"]);
                    return prog;
                });
                var program = MB.ProgramManager.get(this.mainShader);
                var uniformPerDrawBuffer = new MB.VertexUBO(program.id(), "ControlPoints", 0);
                this.numPoints = 256;
                var pointsPerCircle = 25;
                var fb = new Float32Array(4 * this.numPoints);
                for (var j = 0; j < this.numPoints * 4; j += 4) {
                    var i = j * 1.0;
                    var scale = 1.0 - i / this.numPoints;
                    var t = i / pointsPerCircle;
                    var ang = 2.0 * Math.PI * t;
                    var x = Math.cos(ang) * scale;
                    var y = i / 10.0;
                    var z = Math.sin(ang) * scale;
                    fb[j] = x;
                    fb[j + 1] = y;
                    fb[j + 2] = z;
                    fb[j + 3] = 1.0;
                }
                MB.GlobalState.setLineWidth(20.5);
                uniformPerDrawBuffer.update(fb);
            };
            ;
            MyScene.prototype.update = function (dt) {
                this.angle += MB.Timer.deltaTime() * 0.001;
                this.__resize__();
            };
            ;
            MyScene.prototype.draw = function (dt) {
                if (this.drawTick === false) {
                    return;
                }
                MB.Core.getInstance().clearColorAndDepth();
                var prog = MB.ProgramManager.get(this.mainShader);
                prog.use();
                var pp = mat4.create();
                mat4.perspective(pp, MB.Mathf.degToRad(45.0), 1.0, 0.1, 100.0);
                var vv = mat4.create();
                mat4.lookAt(vv, vec3.fromValues(0.0, 0.0, 50.0), vec3.fromValues(0.0, 20.0, 0.0), vec3.fromValues(0.0, 1.0, 0.0));
                var mm = mat4.create();
                mat4.mul(mm, pp, vv);
                mat4.rotateY(mm, mm, this.angle * 0.5);
                var gl = MB.Core.getInstance().getGL();
                prog.sendUniformMat4("transform", mm);
                prog.sendUniform1i("lod", this.text.lod);
                prog.sendUniform1i("numPoints", this.text.numPoints);
                gl.drawArrays(gl.LINE_STRIP, 0, this.text.lod * (this.text.numPoints + 1) + 1);
            };
            ;
            MyScene.prototype.cameraUpdate = function () {
            };
            ;
            MyScene.prototype.textCB = function (gui) {
                gui.add(this.text, "lod", 1, 25);
                gui.add(this.text, "numPoints", 1, 256);
            };
            ;
            return MyScene;
        }(MB.Scene));
        ;
        var myScene;
        window.onload = function () {
            myScene = new MyScene();
            myScene.start();
        };
    </script>
</body>
</html>
